<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Clay Machine Glow â€” Find the Machine in Toronto</title>

<!-- Session 7: Meta tags -->
<meta name="description" content="A Where's Waldo-style hidden object game. Find the ceramic vending machine hidden in 10 beautifully illustrated Toronto scenes.">
<meta name="theme-color" content="#1a1a2e">
<meta property="og:title" content="Clay Machine Glow â€” Find the Machine">
<meta property="og:description" content="A Where's Waldo-style game across 10 Toronto scenes. Find the hidden ceramic vending machine.">
<meta property="og:image" content="https://alangertner.github.io/claymachineglow/og-image.png">
<meta property="og:url" content="https://alangertner.github.io/claymachineglow/">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Clay Machine Glow â€” Find the Machine">
<meta name="twitter:description" content="Find the hidden ceramic vending machine in 10 Toronto scenes.">
<meta name="twitter:image" content="https://alangertner.github.io/claymachineglow/og-image.png">

<!-- Session 7: Favicon (inline SVG base64) -->
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PGNpcmNsZSBjeD0iMTYiIGN5PSIxNiIgcj0iMTUiIGZpbGw9IiNmZmQ3MDAiLz48cmVjdCB4PSIxMSIgeT0iOCIgd2lkdGg9IjEwIiBoZWlnaHQ9IjE2IiByeD0iMSIgZmlsbD0iIzFhMWEyZSIvPjxyZWN0IHg9IjEzIiB5PSIxMCIgd2lkdGg9IjYiIGhlaWdodD0iNCIgZmlsbD0iIzRhOWVkOSIvPjxjaXJjbGUgY3g9IjE2IiBjeT0iMTkiIHI9IjIiIGZpbGw9IiNmZmQ3MDAiLz48L3N2Zz4=">

<!-- Session 7: Preconnect for faster font loading -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Lilita+One&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">

<style>
/* ===== RESET & BASE ===== */
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { 
  width: 100%; height: 100%; 
  overflow: hidden; 
  background: #1a1a2e; 
  font-family: 'Segoe UI', -apple-system, sans-serif; 
  touch-action: none;
  overscroll-behavior: none;
  -webkit-overflow-scrolling: touch;
}

/* ===== CSS VARIABLES ===== */
:root {
  --gold: #ffd700;
  --gold-warm: #e8b800;
  --red: #d41920;
  --blue: #2952a3;
  --navy: #1a1a2e;
  --cream: #fafaf7;
  --ease-out-back: cubic-bezier(0.34, 1.56, 0.64, 1);
  --ease-out-smooth: cubic-bezier(0.25, 1, 0.5, 1);
}

/* ===== TITLE SCREEN ===== */
#title-screen {
  position: fixed; inset: 0; z-index: 500;
  display: flex; align-items: center; justify-content: center;
  overflow: hidden;
  background: #0099cc;
}

.title-bg {
  position: absolute; inset: -40px;
  background: url('title-bg-v3.png') center center;
  background-size: cover;
  opacity: 0;
  animation: bgFadeIn 0.6s ease-out 0.1s forwards, bgDrift 30s ease-in-out infinite;
}

@keyframes bgFadeIn {
  to { opacity: 1; }
}

@keyframes bgDrift {
  0%, 100% { transform: translate(0, 0); }
  50% { transform: translate(-3px, -2px); }
}

/* ---- Postcard ---- */
.title-card {
  position: relative; z-index: 2;
  background: var(--cream);
  padding: 18px 30px 18px 30px;
  box-shadow:
    -3px 5px 10px rgba(0,0,0,0.25),
    -1px 2px 4px rgba(0,0,0,0.12),
    0 0 0 1px rgba(0,0,0,0.04);
  max-width: 420px; width: 80vw;
  text-align: center;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='4' height='4'%3E%3Crect width='4' height='4' fill='%23fafaf7'/%3E%3Crect x='0' y='0' width='1' height='1' fill='%23f5f5f0' opacity='0.3'/%3E%3C/svg%3E");
  opacity: 0;
  transform: translateY(40px) rotate(8deg);
  animation: cardSlideIn 0.7s var(--ease-out-back) 0.3s forwards;
}

@keyframes cardSlideIn {
  to { opacity: 1; transform: translateY(0) rotate(8deg); }
}

/* ---- Postmark stamps ---- */
.title-stamps {
  display: flex; justify-content: center; align-items: flex-end; gap: 4px;
  margin-bottom: 8px;
}

.stamp {
  width: 66px; height: 66px;
  position: relative;
  opacity: 0;
  transform: scale(1.3) rotate(0deg);
}

.stamp:nth-child(1) { animation: stampIn 0.3s var(--ease-out-back) 0.7s forwards; }
.stamp:nth-child(2) { animation: stampIn 0.3s var(--ease-out-back) 0.85s forwards; }
.stamp:nth-child(3) { animation: stampIn 0.3s var(--ease-out-back) 1s forwards; }
.stamp:nth-child(4) { animation: stampIn 0.3s var(--ease-out-back) 1.15s forwards; }

@keyframes stampIn {
  0% { opacity: 0; transform: scale(1.4) rotate(-5deg); }
  60% { opacity: 0.6; transform: scale(0.95) rotate(2deg); }
  100% { opacity: 0.6; transform: scale(1) rotate(0deg); }
}

.stamp:nth-child(1) { --rotate: -6deg; }
.stamp:nth-child(2) { --rotate: 3deg; }
.stamp:nth-child(3) { --rotate: -2deg; }
.stamp svg { width: 100%; height: 100%; }

/* ---- Postage stamp (4th) ---- */
.stamp-postage {
  width: 68px; height: 80px;
  background: #d8e4f8;
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  position: relative;
  padding: 4px;
  -webkit-mask-image: radial-gradient(circle 3px at 3px 0, transparent 2.5px, black 3px),
    radial-gradient(circle 3px at 3px 0, transparent 2.5px, black 3px),
    radial-gradient(circle 3px at 0 3px, transparent 2.5px, black 3px),
    radial-gradient(circle 3px at 0 3px, transparent 2.5px, black 3px),
    linear-gradient(black, black);
  -webkit-mask-size: 6px 4px, 6px 4px, 4px 6px, 4px 6px, calc(100% - 6px) calc(100% - 6px);
  -webkit-mask-position: top left, bottom left, top left, top right, 3px 3px;
  -webkit-mask-repeat: repeat-x, repeat-x, repeat-y, repeat-y, no-repeat;
  -webkit-mask-composite: source-over;
  mask-composite: add;
  transform: rotate(5deg);
}

.stamp-postage img {
  width: 50px; height: 54px;
  object-fit: contain;
}

.stamp-postage-top,
.stamp-postage-bottom {
  font-family: 'Lilita One', sans-serif;
  font-size: 6px;
  color: #2a3a6a;
  text-transform: uppercase;
  letter-spacing: 0.8px;
  line-height: 1;
}

/* ---- Title typography with staggered entrance ---- */
.title-line1,
.title-line2,
.title-line3 {
  opacity: 0;
  transform: translateY(10px);
}

.title-line1 {
  font-family: 'Lilita One', sans-serif;
  font-size: clamp(32px, 8.5vw, 56px);
  color: var(--blue);
  line-height: 1;
  letter-spacing: 2px;
  animation: titleLineIn 0.5s var(--ease-out-smooth) 1.3s forwards;
}

.title-line2 {
  font-family: 'Lilita One', sans-serif;
  font-size: clamp(36px, 9.5vw, 64px);
  color: var(--blue);
  line-height: 0.95;
  letter-spacing: 2px;
  animation: titleLineIn 0.5s var(--ease-out-smooth) 1.45s forwards;
}

.title-line3 {
  font-family: 'Lilita One', sans-serif;
  font-size: clamp(44px, 12vw, 80px);
  color: var(--red);
  line-height: 0.95;
  letter-spacing: 3px;
  animation: titleLineIn 0.5s var(--ease-out-smooth) 1.6s forwards;
}

@keyframes titleLineIn {
  to { opacity: 1; transform: translateY(0); }
}

/* ---- Author strip ---- */
.title-author {
  margin-top: 10px;
  display: flex; align-items: center; justify-content: center; gap: 8px;
  opacity: 0;
  animation: fadeIn 0.5s ease-out 1.8s forwards;
}

@keyframes fadeIn {
  to { opacity: 1; }
}

.title-author-line { height: 2.5px; width: 32px; background: #222; }
.title-author-name {
  font-family: 'Segoe UI', Helvetica, Arial, sans-serif;
  font-size: 12px; font-weight: 900;
  color: #222; letter-spacing: 3.5px;
  text-transform: uppercase;
}

/* ---- Yellow O circle ---- */
.title-yellow-circle {
  position: fixed;
  width: 68px; height: 68px;
  border: 6px solid var(--gold-warm);
  border-radius: 50%;
  z-index: 3;
  display: flex; align-items: center; justify-content: center;
  background: transparent;
  opacity: 0;
  animation: circleFloat 0.8s var(--ease-out-back) 2.2s forwards;
}

@keyframes circleFloat {
  0% { opacity: 0; transform: translateX(30px); }
  100% { opacity: 1; transform: translateX(0); }
}

.title-yellow-circle img {
  width: 42px; height: 42px;
  object-fit: contain;
}

/* ---- Red badge ---- */
.title-badge {
  position: absolute;
  top: 10px; left: 10px;
  width: 62px; height: 62px;
  border-radius: 50%;
  background: #cc1111;
  border: 3px solid #fff;
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  box-shadow: 1px 2px 6px rgba(0,0,0,0.35);
  z-index: 10;
  opacity: 0;
  transform: scale(0);
  animation: badgePop 0.4s var(--ease-out-back) 0.5s forwards;
}

@keyframes badgePop {
  to { opacity: 1; transform: scale(1); }
}

.title-badge svg { width: 100%; height: 100%; }

/* ---- Start button ---- */
.title-cta-area {
  position: relative;
  z-index: 3;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  margin-top: 22px;
  opacity: 0;
  transform: translateY(15px);
  animation: ctaIn 0.6s var(--ease-out-back) 2s forwards;
}

@keyframes ctaIn {
  to { opacity: 1; transform: translateY(0); }
}

#start-btn {
  position: relative;
  padding: 12px 48px;
  font-family: 'Lilita One', sans-serif;
  font-size: 26px;
  letter-spacing: 2px;
  background: var(--gold-warm);
  color: var(--navy);
  border: 3px solid #222;
  border-radius: 50px;
  cursor: pointer;
  box-shadow: 3px 4px 0 #222;
  transition: transform 0.15s var(--ease-out-back), box-shadow 0.15s ease, background 0.2s ease;
}

#start-btn:hover {
  transform: translateY(-2px);
  box-shadow: 4px 6px 0 #222;
}

#start-btn:active {
  transform: translateY(3px);
  box-shadow: 0 1px 0 #222;
}

#start-btn.loading {
  background: #cca800;
  cursor: wait;
}

#start-btn.loading::after {
  content: '';
  position: absolute;
  inset: -6px;
  border: 3px solid transparent;
  border-top-color: var(--gold);
  border-radius: 50px;
  animation: btnSpin 1s linear infinite;
}

@keyframes btnSpin {
  to { transform: rotate(360deg); }
}

#start-btn.ready {
  animation: btnReady 0.4s var(--ease-out-back);
}

@keyframes btnReady {
  0% { transform: scale(1); }
  50% { transform: scale(1.05); }
  100% { transform: scale(1); }
}

.title-subtitle {
  font-family: 'Space Mono', monospace;
  font-size: 10px;
  letter-spacing: 2px;
  color: rgba(0,0,0,0.5);
  text-transform: uppercase;
}

/* ===== HUD ===== */
#hud {
  position: fixed; top: 0; left: 0; right: 0; z-index: 100;
  display: none;
  justify-content: space-between; align-items: flex-start;
  padding: 12px 20px;
  background: linear-gradient(180deg, rgba(0,0,0,0.75) 0%, rgba(0,0,0,0.3) 60%, transparent 100%);
  pointer-events: none;
}

#hud.visible {
  display: flex;
}

.hud-left {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.scene-name {
  color: #fff;
  font-size: 18px;
  font-weight: 700;
  text-shadow: 0 2px 4px rgba(0,0,0,0.5);
}

.scene-counter {
  font-family: 'Space Mono', monospace;
  font-size: 11px;
  color: rgba(255,255,255,0.6);
  letter-spacing: 1px;
}

.timer {
  color: var(--gold);
  font-size: 24px;
  font-weight: 700;
  font-variant-numeric: tabular-nums;
  font-family: 'Space Mono', monospace;
  text-shadow: 0 2px 4px rgba(0,0,0,0.5);
}

/* ===== GAME CONTAINER ===== */
#game-container {
  position: relative;
  width: 100%;
  height: 100%;
  overflow: hidden;
  background: var(--navy);
}

#game-container.playing {
  cursor: none;
}

@media (hover: none) {
  #game-container.playing { cursor: default; }
}

#scene-img {
  position: absolute;
  top: 0; left: 0;
  transform-origin: 0 0;
  will-change: transform, opacity;
  transition: opacity 0.4s ease-out;
  user-select: none;
  -webkit-user-drag: none;
  pointer-events: none;
}

#scene-img.loading {
  opacity: 0;
}

/* Custom cursor */
#custom-cursor {
  position: fixed;
  width: 32px; height: 32px;
  pointer-events: none;
  z-index: 1000;
  opacity: 0;
  transition: transform 0.1s ease-out, opacity 0.2s ease;
  transform: translate(-50%, -50%) scale(1);
}

#custom-cursor.active {
  transform: translate(-50%, -50%) scale(0.9);
}

#custom-cursor.visible {
  opacity: 1;
}

/* ===== LOADING INTERSTITIAL ===== */
#loading-interstitial {
  position: fixed;
  inset: 0;
  z-index: 150;
  background: var(--navy);
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 20px;
}

#loading-interstitial.visible {
  display: flex;
}

.loading-scene-name {
  font-family: 'Lilita One', sans-serif;
  font-size: clamp(28px, 8vw, 48px);
  color: var(--gold);
  text-align: center;
  opacity: 0;
  animation: loadingPulse 1.5s ease-in-out infinite;
}

@keyframes loadingPulse {
  0%, 100% { opacity: 0.5; }
  50% { opacity: 1; }
}

.loading-progress {
  width: 60px; height: 60px;
  border: 3px solid rgba(255,215,0,0.2);
  border-top-color: var(--gold);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

/* ===== HINT BUTTON ===== */
#hint-btn {
  position: fixed;
  bottom: 20px; right: 20px;
  z-index: 100;
  display: none;
  background: rgba(0,0,0,0.6);
  color: var(--gold);
  border: 2px solid var(--gold);
  border-radius: 50%;
  width: 48px; height: 48px;
  font-size: 22px;
  font-weight: bold;
  cursor: pointer;
  transition: transform 0.2s var(--ease-out-back), background 0.2s ease;
  backdrop-filter: blur(4px);
  -webkit-backdrop-filter: blur(4px);
}

#hint-btn:hover {
  background: rgba(255,215,0,0.2);
  transform: scale(1.1);
}

#hint-btn:active {
  transform: scale(0.95);
}

/* tooltip removed â€” was rendering over scene */

/* ===== MUTE BUTTON ===== */
#mute-btn {
  position: fixed;
  bottom: 20px; left: 20px;
  z-index: 100;
  display: none;
  background: rgba(0,0,0,0.6);
  color: #fff;
  border: 2px solid rgba(255,255,255,0.3);
  border-radius: 50%;
  width: 44px; height: 44px;
  font-size: 18px;
  cursor: pointer;
  transition: transform 0.2s var(--ease-out-back);
  backdrop-filter: blur(4px);
  -webkit-backdrop-filter: blur(4px);
}

#mute-btn:active {
  transform: scale(0.9);
}

/* ===== CLICK FEEDBACK ===== */
.click-feedback {
  position: absolute;
  pointer-events: none;
  z-index: 50;
  border-radius: 50%;
  border: 2px solid rgba(150,150,150,0.5);
  animation: missFade 0.5s ease-out forwards;
}

@keyframes missFade {
  0% { opacity: 0.7; transform: scale(0.8); }
  100% { opacity: 0; transform: scale(1.2); }
}

/* ===== FOUND EFFECTS ===== */
.found-pulse {
  position: absolute;
  pointer-events: none;
  z-index: 50;
  border: 3px solid var(--gold);
  border-radius: 50%;
  animation: pulse 0.8s ease-out forwards;
}

.found-pulse:nth-child(2) { animation-delay: 0.15s; }
.found-pulse:nth-child(3) { animation-delay: 0.3s; }

@keyframes pulse {
  0% { opacity: 1; transform: scale(1); box-shadow: 0 0 20px var(--gold); }
  50% { opacity: 0.8; transform: scale(1.3); }
  100% { opacity: 0; transform: scale(1.6); }
}

.particle {
  position: absolute;
  pointer-events: none;
  z-index: 51;
  border-radius: 50%;
  background: var(--gold);
  animation: particleFly 0.8s ease-out forwards;
}

@keyframes particleFly {
  0% { opacity: 1; }
  100% { opacity: 0; }
}

/* Screen shake */
@keyframes shake {
  0%, 100% { transform: translate(0, 0); }
  20% { transform: translate(-3px, 2px); }
  40% { transform: translate(3px, -2px); }
  60% { transform: translate(-2px, -2px); }
  80% { transform: translate(2px, 2px); }
}

#game-container.shake {
  animation: shake 0.15s ease-out;
}

/* Golden glow on find */
#game-container.glow::after {
  content: '';
  position: absolute;
  inset: 0;
  box-shadow: inset 0 0 100px rgba(255,215,0,0.3);
  pointer-events: none;
  animation: glowFade 0.6s ease-out forwards;
}

@keyframes glowFade {
  to { opacity: 0; }
}

/* ===== FOUND BANNER ===== */
#found-banner {
  position: fixed;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  z-index: 200;
  text-align: center;
  opacity: 0;
  pointer-events: none;
}

#found-banner .location {
  font-family: 'Lilita One', sans-serif;
  font-size: clamp(32px, 10vw, 56px);
  color: var(--gold);
  text-shadow: 0 0 30px rgba(255,215,0,0.8), 0 4px 8px rgba(0,0,0,0.5);
  white-space: nowrap;
}

#found-banner .checkmark {
  display: inline-block;
  color: #4ade80;
  margin-left: 10px;
}

#found-banner.show {
  opacity: 1;
  animation: bannerReveal 1.2s var(--ease-out-back);
}

@keyframes bannerReveal {
  0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5) rotate(-5deg); }
  30% { opacity: 1; transform: translate(-50%, -50%) scale(1.1) rotate(2deg); }
  50% { transform: translate(-50%, -50%) scale(0.98) rotate(-1deg); }
  100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
}

/* ===== END SCREEN ===== */
#end-screen {
  position: fixed;
  inset: 0;
  z-index: 300;
  background: rgba(10, 10, 30, 0.97);
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 20px;
  overflow-y: auto;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='4' height='4'%3E%3Crect width='4' height='4' fill='rgba(26,26,46,1)'/%3E%3Crect x='0' y='0' width='1' height='1' fill='rgba(255,255,255,0.02)'/%3E%3C/svg%3E");
}

#end-screen.visible {
  display: flex;
}

.end-content {
  max-width: 400px;
  width: 100%;
  text-align: center;
}

.end-title {
  font-family: 'Lilita One', sans-serif;
  font-size: clamp(32px, 10vw, 48px);
  color: var(--gold);
  margin-bottom: 8px;
  opacity: 0;
  transform: translateY(20px);
  animation: endItemIn 0.6s var(--ease-out-back) 0.1s forwards;
}

.end-subtitle {
  font-family: 'Space Mono', monospace;
  font-size: 12px;
  color: rgba(255,255,255,0.5);
  letter-spacing: 2px;
  text-transform: uppercase;
  margin-bottom: 24px;
  opacity: 0;
  animation: endItemIn 0.5s ease-out 0.3s forwards;
}

@keyframes endItemIn {
  to { opacity: 1; transform: translateY(0); }
}

.end-hero-time {
  font-family: 'Lilita One', sans-serif;
  font-size: clamp(48px, 15vw, 72px);
  color: #fff;
  margin-bottom: 30px;
  opacity: 0;
  transform: scale(0.8);
  animation: heroTimeIn 0.7s var(--ease-out-back) 0.2s forwards;
}

@keyframes heroTimeIn {
  to { opacity: 1; transform: scale(1); }
}

.end-times-grid {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: 8px;
  margin-bottom: 30px;
  opacity: 0;
  animation: endItemIn 0.5s ease-out 0.5s forwards;
}

@media (max-width: 480px) {
  .end-times-grid {
    grid-template-columns: repeat(5, 1fr);
    gap: 4px;
  }
}

.end-stamp {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 8px 4px;
  background: rgba(255,255,255,0.05);
  border: 1px solid rgba(255,215,0,0.3);
  border-radius: 8px;
}

.end-stamp-num {
  font-family: 'Lilita One', sans-serif;
  font-size: 18px;
  color: var(--gold);
}

.end-stamp-time {
  font-family: 'Space Mono', monospace;
  font-size: 9px;
  color: rgba(255,255,255,0.7);
}

.end-buttons {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-bottom: 30px;
  opacity: 0;
  animation: endItemIn 0.5s ease-out 0.7s forwards;
}

#share-btn {
  padding: 14px 40px;
  font-family: 'Lilita One', sans-serif;
  font-size: 22px;
  letter-spacing: 1px;
  background: var(--gold);
  color: var(--navy);
  border: none;
  border-radius: 50px;
  cursor: pointer;
  transition: transform 0.2s var(--ease-out-back), box-shadow 0.2s ease;
  box-shadow: 0 4px 15px rgba(255,215,0,0.3);
}

#share-btn:hover {
  transform: scale(1.05);
  box-shadow: 0 6px 20px rgba(255,215,0,0.4);
}

#share-btn:active {
  transform: scale(0.98);
}

#share-btn.copied {
  background: #4ade80;
}

#play-again-btn {
  padding: 12px 30px;
  font-family: 'Space Mono', monospace;
  font-size: 14px;
  background: transparent;
  color: rgba(255,255,255,0.7);
  border: 2px solid rgba(255,255,255,0.3);
  border-radius: 50px;
  cursor: pointer;
  transition: all 0.2s ease;
}

#play-again-btn:hover {
  background: rgba(255,255,255,0.1);
  border-color: rgba(255,255,255,0.5);
  color: #fff;
}

.end-cta {
  opacity: 0;
  animation: endItemIn 0.5s ease-out 0.9s forwards;
}

.end-cta-text {
  font-size: 14px;
  color: rgba(255,255,255,0.5);
  margin-bottom: 8px;
}

.end-cta-link {
  font-family: 'Lilita One', sans-serif;
  font-size: 16px;
  color: var(--gold);
  text-decoration: none;
  transition: opacity 0.2s ease;
}

.end-cta-link:hover {
  opacity: 0.8;
}

/* ===== ACCESSIBILITY ===== */
.visually-hidden {
  position: absolute;
  width: 1px; height: 1px;
  padding: 0; margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}
</style>
</head>
<body>

<!-- Skip link for accessibility -->
<a href="#game-container" class="visually-hidden">Skip to game</a>

<!-- TITLE SCREEN -->
<div id="title-screen" role="dialog" aria-label="Clay Machine Glow - Start Screen">
  <div class="title-bg"></div>

  <!-- Red badge -->
  <div class="title-badge" aria-hidden="true">
    <svg viewBox="0 0 62 62">
      <circle cx="31" cy="31" r="28" fill="none" stroke="rgba(255,255,255,0.3)" stroke-width="1"/>
      <text x="31" y="18" text-anchor="middle" font-family="'Lilita One',sans-serif" font-size="6" fill="#fff" letter-spacing="0.5">CLAY MACHINE</text>
      <text x="31" y="25" text-anchor="middle" font-family="'Lilita One',sans-serif" font-size="6" fill="#fff" letter-spacing="0.5">GLOW</text>
      <text x="31" y="47" text-anchor="middle" font-family="'Lilita One',sans-serif" font-size="22" fill="#ffd700">1</text>
    </svg>
  </div>

  <!-- Yellow circle with machine -->
  <div class="title-yellow-circle" id="title-yellow-circle" aria-hidden="true">
    <img src="machine-sprite.png" alt="">
  </div>

  <div style="position:relative;z-index:2;display:flex;flex-direction:column;align-items:center;">
    <div class="title-card">
      <!-- Postmark stamps row -->
      <div class="title-stamps" aria-hidden="true">
        <div class="stamp">
          <svg viewBox="0 0 80 80">
            <circle cx="40" cy="40" r="37" fill="none" stroke="#555" stroke-width="2"/>
            <circle cx="40" cy="40" r="33" fill="none" stroke="#555" stroke-width="1"/>
            <circle cx="40" cy="40" r="29" fill="none" stroke="#555" stroke-width="0.5"/>
            <line x1="3" y1="40" x2="77" y2="40" stroke="#555" stroke-width="0.7"/>
            <path id="p1t" d="M10,38 A30,30 0 0,1 70,38" fill="none"/>
            <path id="p1b" d="M70,42 A30,30 0 0,1 10,42" fill="none"/>
            <text font-size="6.5" fill="#444" font-weight="700" font-family="sans-serif"><textPath href="#p1t" startOffset="50%" text-anchor="middle">FIND THE</textPath></text>
            <text font-size="6.5" fill="#444" font-weight="700" font-family="sans-serif"><textPath href="#p1b" startOffset="50%" text-anchor="middle">MACHINE</textPath></text>
            <text x="40" y="42" text-anchor="middle" font-size="7" fill="#444" font-weight="800" font-family="sans-serif">KENSINGTON</text>
          </svg>
        </div>
        <div class="stamp">
          <svg viewBox="0 0 80 80">
            <circle cx="40" cy="40" r="37" fill="none" stroke="#555" stroke-width="2"/>
            <circle cx="40" cy="40" r="33" fill="none" stroke="#555" stroke-width="1"/>
            <circle cx="40" cy="40" r="29" fill="none" stroke="#555" stroke-width="0.5"/>
            <line x1="3" y1="40" x2="77" y2="40" stroke="#555" stroke-width="0.7"/>
            <path id="p2t" d="M10,38 A30,30 0 0,1 70,38" fill="none"/>
            <path id="p2b" d="M70,42 A30,30 0 0,1 10,42" fill="none"/>
            <text font-size="6.5" fill="#444" font-weight="700" font-family="sans-serif"><textPath href="#p2t" startOffset="50%" text-anchor="middle">FIND THE</textPath></text>
            <text font-size="6.5" fill="#444" font-weight="700" font-family="sans-serif"><textPath href="#p2b" startOffset="50%" text-anchor="middle">MACHINE</textPath></text>
            <text x="40" y="42" text-anchor="middle" font-size="6.5" fill="#444" font-weight="800" font-family="sans-serif">DUNDAS SQ</text>
          </svg>
        </div>
        <div class="stamp">
          <svg viewBox="0 0 80 80">
            <circle cx="40" cy="40" r="37" fill="none" stroke="#555" stroke-width="2"/>
            <circle cx="40" cy="40" r="33" fill="none" stroke="#555" stroke-width="1"/>
            <circle cx="40" cy="40" r="29" fill="none" stroke="#555" stroke-width="0.5"/>
            <line x1="3" y1="40" x2="77" y2="40" stroke="#555" stroke-width="0.7"/>
            <path id="p3t" d="M10,38 A30,30 0 0,1 70,38" fill="none"/>
            <path id="p3b" d="M70,42 A30,30 0 0,1 10,42" fill="none"/>
            <text font-size="6.5" fill="#444" font-weight="700" font-family="sans-serif"><textPath href="#p3t" startOffset="50%" text-anchor="middle">FIND THE</textPath></text>
            <text font-size="6.5" fill="#444" font-weight="700" font-family="sans-serif"><textPath href="#p3b" startOffset="50%" text-anchor="middle">MACHINE</textPath></text>
            <text x="40" y="42" text-anchor="middle" font-size="6" fill="#444" font-weight="800" font-family="sans-serif">DISTILLERY</text>
          </svg>
        </div>
        <!-- Rectangular postage stamp -->
        <div class="stamp-postage">
          <div class="stamp-postage-top">FIND THE</div>
          <img src="machine-sprite.png" alt="">
          <div class="stamp-postage-bottom">MACHINE</div>
        </div>
      </div>

      <!-- Title text -->
      <div class="title-line1">CLAY</div>
      <div class="title-line2">MACHINE</div>
      <div class="title-line3">GLOW</div>

      <!-- Author -->
      <div class="title-author">
        <div class="title-author-line"></div>
        <span class="title-author-name">Alan Gertner</span>
        <div class="title-author-line"></div>
      </div>
    </div>

    <div class="title-cta-area">
      <button id="start-btn" class="loading" aria-label="Start the game">LOADING...</button>
      <div class="title-subtitle">10 SCENES Â· FIND THE MACHINE</div>
    </div>
  </div>
</div>

<!-- HUD -->
<div id="hud" aria-live="polite">
  <div class="hud-left">
    <div class="scene-name" id="scene-label"></div>
    <div class="scene-counter" id="scene-counter"></div>
  </div>
  <div class="timer" id="timer">0.0s</div>
</div>

<!-- Loading Interstitial -->
<div id="loading-interstitial" aria-live="polite">
  <div class="loading-scene-name" id="loading-scene-name"></div>
  <div class="loading-progress"></div>
</div>

<!-- Game Container -->
<div id="game-container" role="application" aria-label="Find the hidden vending machine" oncontextmenu="return false">
  <img id="scene-img" alt="Toronto scene - find the vending machine">
</div>

<!-- Custom Cursor -->
<div id="custom-cursor" aria-hidden="true">
  <svg width="32" height="32" viewBox="0 0 32 32" fill="none">
    <circle cx="12" cy="12" r="9" stroke="#ffd700" stroke-width="2.5" fill="rgba(255,215,0,0.1)"/>
    <line x1="19" y1="19" x2="28" y2="28" stroke="#ffd700" stroke-width="3" stroke-linecap="round"/>
  </svg>
</div>

<!-- Buttons -->
<button id="hint-btn" title="Hint" aria-label="Get a hint">?</button>
<button id="mute-btn" title="Toggle sound" aria-label="Toggle sound">ðŸ”Š</button>

<!-- Found Banner -->
<div id="found-banner" aria-live="assertive">
  <span class="location"></span><span class="checkmark">âœ“</span>
</div>

<!-- End Screen -->
<div id="end-screen" role="dialog" aria-label="Game Complete">
  <div class="end-content">
    <div class="end-title">All Found!</div>
    <div class="end-subtitle">You found all 10 machines</div>
    <div class="end-hero-time" id="end-hero-time"></div>
    <div class="end-times-grid" id="end-times-grid"></div>
    <div class="end-buttons">
      <button id="share-btn" aria-label="Share your results">SHARE</button>
      <button id="play-again-btn" aria-label="Play again">PLAY AGAIN</button>
    </div>
    <div class="end-cta">
      <div class="end-cta-text">A real machine is hidden somewhere in Toronto.</div>
      <a href="https://www.gardinermuseum.on.ca/" target="_blank" rel="noopener" class="end-cta-link">Discover at the Gardiner Museum â†’</a>
    </div>
  </div>
</div>

<script>
// ===== SCENE DATA =====
const SCENES = [
  { img: 'scenes/scene1.png',  name: 'Kensington Market',      vendingX: 0.167, vendingY: 0.454 },
  { img: 'scenes/scene2.png',  name: 'Nathan Phillips Square', vendingX: 0.738, vendingY: 0.432 },
  { img: 'scenes/scene3.png',  name: 'Dundas Square',          vendingX: 0.302, vendingY: 0.787 },
  { img: 'scenes/scene4.png',  name: 'St. Lawrence Market',    vendingX: 0.452, vendingY: 0.866 },
  { img: 'scenes/scene5.png',  name: 'High Park',              vendingX: 0.364, vendingY: 0.497 },
  { img: 'scenes/scene6.png',  name: 'Toronto Islands',        vendingX: 0.745, vendingY: 0.803 },
  { img: 'scenes/scene7.png',  name: 'Chinatown Spadina',      vendingX: 0.254, vendingY: 0.676 },
  { img: 'scenes/scene8.png',  name: 'PATH Underground',       vendingX: 0.768, vendingY: 0.361 },
  { img: 'scenes/scene9.png',  name: 'Distillery District',    vendingX: 0.737, vendingY: 0.675 },
  { img: 'scenes/scene10.png', name: 'Gardiner Museum',        vendingX: 0.435, vendingY: 0.366 },
];

const HIT_RADIUS = 180;

// ===== STATE =====
let currentScene = 0;
let times = [];
let sceneStart = 0;
let gameActive = false;
let found = false;

// Image state
let sceneImg = null;
let imgLoaded = false;
let imgWidth = 0, imgHeight = 0;

// Preload cache
const preloadCache = {};
let preloadQueue = [];
let preloading = false;

// Pan/zoom state
let panX = 0, panY = 0, scale = 1, minScale = 1;
let targetPanX = 0, targetPanY = 0, targetScale = 1;

// Drag state
let dragging = false;
let dragStartX = 0, dragStartY = 0;
let panStartX = 0, panStartY = 0;
let clickIntent = true;
let lastPinchDist = 0;

// Momentum
let velocityX = 0, velocityY = 0;
let lastDragX = 0, lastDragY = 0;
let lastDragTime = 0;
let momentumRAF = null;

// Double tap
let lastTapTime = 0;
let lastTapX = 0, lastTapY = 0;

// DOM refs
let container, imgEl, hud, hintBtn, muteBtn, customCursor;

// ===== AUDIO SYSTEM =====
let audioCtx = null;
let isMuted = false;
let ambientOsc = null;
let ambientGain = null;

function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  isMuted = localStorage.getItem('cmg-muted') === 'true';
  updateMuteButton();
}

function startAmbient() {
  if (!audioCtx || ambientOsc) return;
  
  // Very subtle low drone
  ambientOsc = audioCtx.createOscillator();
  ambientGain = audioCtx.createGain();
  const filter = audioCtx.createBiquadFilter();
  
  ambientOsc.type = 'sine';
  ambientOsc.frequency.value = 65;
  filter.type = 'lowpass';
  filter.frequency.value = 100;
  
  ambientGain.gain.value = 0;
  
  ambientOsc.connect(filter);
  filter.connect(ambientGain);
  ambientGain.connect(audioCtx.destination);
  
  ambientOsc.start();
  
  // Fade in
  if (!isMuted) {
    ambientGain.gain.linearRampToValueAtTime(0.025, audioCtx.currentTime + 1);
  }
}

function stopAmbient() {
  if (ambientGain && audioCtx) {
    ambientGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
    setTimeout(() => {
      if (ambientOsc) {
        ambientOsc.stop();
        ambientOsc = null;
        ambientGain = null;
      }
    }, 600);
  }
}

function playFoundSound() {
  if (!audioCtx || isMuted) return;
  
  const now = audioCtx.currentTime;
  
  // Ascending tone (vending machine dispense feel)
  const osc1 = audioCtx.createOscillator();
  const osc2 = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  
  osc1.type = 'sine';
  osc2.type = 'sine';
  osc1.frequency.setValueAtTime(440, now);
  osc1.frequency.linearRampToValueAtTime(660, now + 0.15);
  osc2.frequency.setValueAtTime(444, now);
  osc2.frequency.linearRampToValueAtTime(664, now + 0.15);
  
  gain.gain.setValueAtTime(0.12, now);
  gain.gain.linearRampToValueAtTime(0.08, now + 0.1);
  gain.gain.linearRampToValueAtTime(0, now + 0.25);
  
  osc1.connect(gain);
  osc2.connect(gain);
  gain.connect(audioCtx.destination);
  
  osc1.start(now);
  osc2.start(now);
  osc1.stop(now + 0.3);
  osc2.stop(now + 0.3);
  
  // Ceramic clink
  setTimeout(() => {
    if (!audioCtx || isMuted) return;
    const clickOsc = audioCtx.createOscillator();
    const clickGain = audioCtx.createGain();
    const clickFilter = audioCtx.createBiquadFilter();
    
    clickOsc.type = 'triangle';
    clickOsc.frequency.value = 2200;
    clickFilter.type = 'highpass';
    clickFilter.frequency.value = 1500;
    
    clickGain.gain.setValueAtTime(0.08, audioCtx.currentTime);
    clickGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.08);
    
    clickOsc.connect(clickFilter);
    clickFilter.connect(clickGain);
    clickGain.connect(audioCtx.destination);
    
    clickOsc.start();
    clickOsc.stop(audioCtx.currentTime + 0.1);
  }, 100);
}

function playMissSound() {
  if (!audioCtx || isMuted) return;
  
  // Soft tock
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  const filter = audioCtx.createBiquadFilter();
  
  osc.type = 'sine';
  osc.frequency.value = 150;
  filter.type = 'lowpass';
  filter.frequency.value = 300;
  
  gain.gain.setValueAtTime(0.04, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.08);
  
  osc.connect(filter);
  filter.connect(gain);
  gain.connect(audioCtx.destination);
  
  osc.start();
  osc.stop(audioCtx.currentTime + 0.1);
}

function playTransitionSound() {
  if (!audioCtx || isMuted) return;
  
  // Gentle whoosh
  const bufferSize = audioCtx.sampleRate * 0.25;
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  
  for (let i = 0; i < bufferSize; i++) {
    data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
  }
  
  const source = audioCtx.createBufferSource();
  const gain = audioCtx.createGain();
  const filter = audioCtx.createBiquadFilter();
  
  source.buffer = buffer;
  filter.type = 'bandpass';
  filter.frequency.setValueAtTime(2000, audioCtx.currentTime);
  filter.frequency.linearRampToValueAtTime(500, audioCtx.currentTime + 0.2);
  filter.Q.value = 0.5;
  
  gain.gain.setValueAtTime(0.06, audioCtx.currentTime);
  gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.25);
  
  source.connect(filter);
  filter.connect(gain);
  gain.connect(audioCtx.destination);
  
  source.start();
}

function playZoomShimmer() {
  if (!audioCtx || isMuted) return;
  
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  
  osc.type = 'sine';
  osc.frequency.value = 4000 + Math.random() * 1000;
  
  gain.gain.setValueAtTime(0.008, audioCtx.currentTime);
  gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
  
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  
  osc.start();
  osc.stop(audioCtx.currentTime + 0.12);
}

function updateMuteButton() {
  if (muteBtn) {
    muteBtn.textContent = isMuted ? 'ðŸ”‡' : 'ðŸ”Š';
  }
  if (ambientGain && audioCtx) {
    ambientGain.gain.linearRampToValueAtTime(isMuted ? 0 : 0.025, audioCtx.currentTime + 0.3);
  }
}

function toggleMute() {
  isMuted = !isMuted;
  localStorage.setItem('cmg-muted', isMuted);
  updateMuteButton();
}

// ===== PRELOADING =====
function preloadImage(url) {
  return new Promise((resolve, reject) => {
    if (preloadCache[url]) {
      resolve(preloadCache[url]);
      return;
    }
    
    const img = new Image();
    img.onload = () => {
      preloadCache[url] = img;
      resolve(img);
    };
    img.onerror = () => {
      // Retry once
      const retry = new Image();
      retry.onload = () => {
        preloadCache[url] = retry;
        resolve(retry);
      };
      retry.onerror = () => reject(new Error(`Failed to load: ${url}`));
      retry.src = url;
    };
    img.src = url;
  });
}

function preloadNextScenes() {
  if (preloading || preloadQueue.length === 0) return;
  preloading = true;
  
  const url = preloadQueue.shift();
  preloadImage(url).then(() => {
    preloading = false;
    preloadNextScenes();
  }).catch(() => {
    preloading = false;
    preloadNextScenes();
  });
}

function queuePreload(startIdx) {
  for (let i = startIdx; i < SCENES.length; i++) {
    const url = SCENES[i].img;
    if (!preloadCache[url] && !preloadQueue.includes(url)) {
      preloadQueue.push(url);
    }
  }
  preloadNextScenes();
}

// ===== SCENE LOADING =====
async function loadScene(idx, showInterstitial = false) {
  currentScene = idx;
  found = false;
  imgLoaded = false;
  
  const scene = SCENES[idx];
  const url = scene.img;
  
  // Update HUD
  document.getElementById('scene-label').textContent = scene.name;
  document.getElementById('scene-counter').textContent = `${idx + 1} / ${SCENES.length}`;
  
  // Show interstitial if image not ready
  const interstitial = document.getElementById('loading-interstitial');
  const loadingName = document.getElementById('loading-scene-name');
  
  if (showInterstitial && !preloadCache[url]) {
    loadingName.textContent = scene.name;
    interstitial.classList.add('visible');
    imgEl.classList.add('loading');
  }
  
  try {
    const img = await preloadImage(url);
    
    // Hide interstitial
    interstitial.classList.remove('visible');
    
    // Set image
    imgWidth = img.width;
    imgHeight = img.height;
    imgEl.src = img.src;
    imgEl.style.width = imgWidth + 'px';
    imgEl.style.height = imgHeight + 'px';
    
    // Calculate scale
    const sx = container.clientWidth / imgWidth;
    const sy = container.clientHeight / imgHeight;
    minScale = Math.max(sx, sy);
    scale = minScale;
    targetScale = scale;
    
    // Center image
    panX = (container.clientWidth - imgWidth * scale) / 2;
    panY = (container.clientHeight - imgHeight * scale) / 2;
    targetPanX = panX;
    targetPanY = panY;
    
    clampPan();
    updateTransform();
    
    // Fade in
    imgEl.classList.remove('loading');
    imgLoaded = true;
    sceneStart = performance.now();
    
    // Preload next scenes
    queuePreload(idx + 1);
    
  } catch (err) {
    console.error('Scene load failed:', err);
    interstitial.classList.remove('visible');
    // Could show error UI here
  }
}

// ===== TRANSFORM & RENDERING =====
const DEBUG = new URLSearchParams(window.location.search).has('debug');

function updateTransform() {
  if (!imgEl) return;
  imgEl.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
  
  if (DEBUG && imgLoaded && !found) {
    let dbg = document.getElementById('debug-circle');
    if (!dbg) {
      dbg = document.createElement('div');
      dbg.id = 'debug-circle';
      dbg.style.cssText = 'position:fixed;border:4px solid red;border-radius:50%;pointer-events:none;z-index:99999;box-shadow:0 0 20px red, 0 0 40px red;background:rgba(255,0,0,0.2);';
      document.body.appendChild(dbg);
    }
    const vc = getVendingCenter();
    const screenX = panX + vc.x * scale;
    const screenY = panY + vc.y * scale;
    const r = HIT_RADIUS * scale;
    dbg.style.left = (screenX - r) + 'px';
    dbg.style.top = (screenY - r) + 'px';
    dbg.style.width = (r * 2) + 'px';
    dbg.style.height = (r * 2) + 'px';
    dbg.style.display = 'block';
    
    // Also show coords overlay
    let info = document.getElementById('debug-info');
    if (!info) {
      info = document.createElement('div');
      info.id = 'debug-info';
      info.style.cssText = 'position:fixed;top:40px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.8);color:lime;font:14px monospace;padding:8px 16px;z-index:99999;border-radius:4px;';
      document.body.appendChild(info);
    }
    const s = SCENES[currentScene];
    info.textContent = `Target: (${s.vendingX}, ${s.vendingY}) | Screen: (${screenX.toFixed(0)}, ${screenY.toFixed(0)}) | Scale: ${scale.toFixed(2)}`;
  }
}

function clampPan() {
  const w = imgWidth * scale;
  const h = imgHeight * scale;
  const cw = container.clientWidth;
  const ch = container.clientHeight;
  
  if (w <= cw) {
    panX = (cw - w) / 2;
  } else {
    panX = Math.min(0, Math.max(cw - w, panX));
  }
  
  if (h <= ch) {
    panY = (ch - h) / 2;
  } else {
    panY = Math.min(0, Math.max(ch - h, panY));
  }
  
  targetPanX = panX;
  targetPanY = panY;
}

function screenToImage(sx, sy) {
  return {
    x: (sx - panX) / scale,
    y: (sy - panY) / scale
  };
}

// ===== GAME LOOP =====
let lastFrameTime = 0;

function tick(timestamp) {
  if (!gameActive) return;
  
  const dt = Math.min((timestamp - lastFrameTime) / 1000, 0.1);
  lastFrameTime = timestamp;
  
  // Smooth zoom interpolation
  if (Math.abs(scale - targetScale) > 0.001) {
    scale += (targetScale - scale) * 0.15;
    
    // Adjust pan to zoom toward center
    const cw = container.clientWidth;
    const ch = container.clientHeight;
    panX = targetPanX + (panX - targetPanX) * 0.15;
    panY = targetPanY + (panY - targetPanY) * 0.15;
    
    clampPan();
    updateTransform();
  }
  
  // Timer update
  if (!found && imgLoaded) {
    const elapsed = ((performance.now() - sceneStart) / 1000).toFixed(1);
    document.getElementById('timer').textContent = elapsed + 's';
  }
  
  requestAnimationFrame(tick);
}

function startGameLoop() {
  gameActive = true;
  lastFrameTime = performance.now();
  requestAnimationFrame(tick);
}

function stopGameLoop() {
  gameActive = false;
}

// ===== MOMENTUM =====
function applyMomentum() {
  if (!gameActive || dragging) return;
  
  const friction = 0.92;
  velocityX *= friction;
  velocityY *= friction;
  
  if (Math.abs(velocityX) > 0.5 || Math.abs(velocityY) > 0.5) {
    panX += velocityX;
    panY += velocityY;
    clampPan();
    updateTransform();
    momentumRAF = requestAnimationFrame(applyMomentum);
  } else {
    velocityX = 0;
    velocityY = 0;
  }
}

function stopMomentum() {
  if (momentumRAF) {
    cancelAnimationFrame(momentumRAF);
    momentumRAF = null;
  }
  velocityX = 0;
  velocityY = 0;
}

// ===== HIT DETECTION =====
function getVendingCenter() {
  const s = SCENES[currentScene];
  return {
    x: s.vendingX * imgWidth,
    y: s.vendingY * imgHeight
  };
}

function handleClick(sx, sy) {
  if (found || !imgLoaded) return;
  
  const pt = screenToImage(sx, sy);
  const vc = getVendingCenter();
  const dist = Math.hypot(pt.x - vc.x, pt.y - vc.y);
  
  if (DEBUG) {
    const pctX = (pt.x / imgWidth).toFixed(3);
    const pctY = (pt.y / imgHeight).toFixed(3);
    console.log(`Click: (${pctX}, ${pctY}) | Target: (${SCENES[currentScene].vendingX}, ${SCENES[currentScene].vendingY}) | Dist: ${dist.toFixed(0)} | Radius: ${HIT_RADIUS}`);
    
    // Show click marker
    let marker = document.createElement('div');
    marker.style.cssText = `position:absolute;left:${sx-5}px;top:${sy-5}px;width:10px;height:10px;background:yellow;border-radius:50%;pointer-events:none;z-index:1000;`;
    container.appendChild(marker);
    setTimeout(() => marker.remove(), 3000);
  }
  
  if (dist <= HIT_RADIUS) {
    handleFound(vc, sx, sy);
  } else {
    handleMiss(sx, sy);
  }
}

function handleFound(vc, sx, sy) {
  found = true;
  const elapsed = (performance.now() - sceneStart) / 1000;
  times.push(elapsed);
  
  // Screen shake
  container.classList.add('shake', 'glow');
  setTimeout(() => container.classList.remove('shake', 'glow'), 600);
  
  // Sound
  playFoundSound();
  
  // Create particles
  createParticles(sx, sy);
  
  // Create pulse rings
  const screenX = vc.x * scale + panX;
  const screenY = vc.y * scale + panY;
  createPulseRings(screenX, screenY);
  
  // Show banner with location name
  const banner = document.getElementById('found-banner');
  banner.querySelector('.location').textContent = SCENES[currentScene].name.toUpperCase();
  banner.classList.add('show');
  
  setTimeout(() => {
    banner.classList.remove('show');
    playTransitionSound();
    
    if (currentScene < SCENES.length - 1) {
      // Fade out current scene
      imgEl.classList.add('loading');
      
      setTimeout(() => {
        loadScene(currentScene + 1, true);
      }, 400);
    } else {
      showEndScreen();
    }
  }, 1500);
}

function handleMiss(sx, sy) {
  playMissSound();
  
  // Soft gray circle
  const el = document.createElement('div');
  el.className = 'click-feedback';
  el.style.left = (sx - 15) + 'px';
  el.style.top = (sy - 15) + 'px';
  el.style.width = '30px';
  el.style.height = '30px';
  container.appendChild(el);
  
  setTimeout(() => el.remove(), 500);
}

function createParticles(cx, cy) {
  const count = 18;
  
  for (let i = 0; i < count; i++) {
    const particle = document.createElement('div');
    particle.className = 'particle';
    
    const size = 3 + Math.random() * 5;
    const angle = (Math.PI * 2 * i) / count + Math.random() * 0.3;
    const velocity = 80 + Math.random() * 60;
    const dx = Math.cos(angle) * velocity;
    const dy = Math.sin(angle) * velocity - 30; // slight upward bias
    
    particle.style.width = size + 'px';
    particle.style.height = size + 'px';
    particle.style.left = cx + 'px';
    particle.style.top = cy + 'px';
    
    container.appendChild(particle);
    
    // Animate with physics
    let x = 0, y = 0, vy = dy;
    const gravity = 200;
    let opacity = 1;
    const startTime = performance.now();
    
    function animateParticle() {
      const elapsed = (performance.now() - startTime) / 1000;
      if (elapsed > 0.8 || opacity <= 0) {
        particle.remove();
        return;
      }
      
      x += dx * 0.016;
      vy += gravity * 0.016;
      y += vy * 0.016;
      opacity = 1 - elapsed / 0.8;
      
      particle.style.transform = `translate(${x}px, ${y}px)`;
      particle.style.opacity = opacity;
      
      requestAnimationFrame(animateParticle);
    }
    
    requestAnimationFrame(animateParticle);
  }
}

function createPulseRings(x, y) {
  for (let i = 0; i < 3; i++) {
    const ring = document.createElement('div');
    ring.className = 'found-pulse';
    const r = HIT_RADIUS * scale;
    ring.style.left = (x - r) + 'px';
    ring.style.top = (y - r) + 'px';
    ring.style.width = (r * 2) + 'px';
    ring.style.height = (r * 2) + 'px';
    ring.style.animationDelay = (i * 0.15) + 's';
    container.appendChild(ring);
    
    setTimeout(() => ring.remove(), 1000);
  }
}

// ===== END SCREEN =====
function showEndScreen() {
  stopGameLoop();
  stopAmbient();
  
  hud.classList.remove('visible');
  hintBtn.style.display = 'none';
  muteBtn.style.display = 'none';
  container.classList.remove('playing');
  
  const endScreen = document.getElementById('end-screen');
  const heroTime = document.getElementById('end-hero-time');
  const grid = document.getElementById('end-times-grid');
  
  // Calculate total
  const total = times.reduce((a, b) => a + b, 0);
  const mins = Math.floor(total / 60);
  const secs = (total % 60).toFixed(1);
  heroTime.textContent = mins > 0 ? `${mins}:${secs.padStart(4, '0')}` : `${secs}s`;
  
  // Build grid
  grid.innerHTML = '';
  for (let i = 0; i < times.length; i++) {
    const stamp = document.createElement('div');
    stamp.className = 'end-stamp';
    stamp.innerHTML = `
      <div class="end-stamp-num">${i + 1}</div>
      <div class="end-stamp-time">${times[i].toFixed(1)}s</div>
    `;
    grid.appendChild(stamp);
  }
  
  endScreen.classList.add('visible');
}

function formatShareText() {
  const total = times.reduce((a, b) => a + b, 0);
  const mins = Math.floor(total / 60);
  const secs = Math.floor(total % 60);
  const timeStr = mins > 0 ? `${mins}:${secs.toString().padStart(2, '0')}` : `${total.toFixed(1)}s`;
  
  return `ðŸ” Clay Machine Glow

Found all 10 machines in ${timeStr}!

ðŸªðŸªðŸªðŸªðŸª
ðŸªðŸªðŸªðŸªðŸª

claymachineglow.com`;
}

function shareResults() {
  const text = formatShareText();
  const shareBtn = document.getElementById('share-btn');
  
  if (navigator.share) {
    navigator.share({
      title: 'Clay Machine Glow',
      text: text,
      url: 'https://alangertner.github.io/claymachineglow/'
    }).catch(() => {
      // Fallback to clipboard
      copyToClipboard(text, shareBtn);
    });
  } else {
    copyToClipboard(text, shareBtn);
  }
}

function copyToClipboard(text, btn) {
  navigator.clipboard.writeText(text).then(() => {
    const originalText = btn.textContent;
    btn.textContent = 'COPIED!';
    btn.classList.add('copied');
    
    setTimeout(() => {
      btn.textContent = originalText;
      btn.classList.remove('copied');
    }, 2000);
  });
}

function restartGame() {
  document.getElementById('end-screen').classList.remove('visible');
  times = [];
  currentScene = 0;
  
  hud.classList.add('visible');
  hintBtn.style.display = 'block';
  muteBtn.style.display = 'block';
  container.classList.add('playing');
  
  startGameLoop();
  startAmbient();
  loadScene(0);
}

// ===== HINT SYSTEM =====
let hintAnimation = null;

function animateHint() {
  if (found || !imgLoaded) return;
  
  const vc = getVendingCenter();
  const cw = container.clientWidth;
  const ch = container.clientHeight;
  
  // Hints get vaguer on later scenes
  const hintSpread = 100 + (currentScene * 35);
  const hintAccuracy = 1.0 - (currentScene * 0.06); // 100% â†’ 46%
  const offsetX = (Math.random() - 0.5) * hintSpread;
  const offsetY = (Math.random() - 0.5) * hintSpread;
  const targetX = -(vc.x * scale - cw / 2) + offsetX;
  const targetY = -(vc.y * scale - ch / 2) + offsetY;
  const finalPanX = panX + (targetX - panX) * hintAccuracy;
  const finalPanY = panY + (targetY - panY) * hintAccuracy;
  
  const startPanX = panX;
  const startPanY = panY;
  const startTime = performance.now();
  const duration = 800;
  
  function animate() {
    const elapsed = performance.now() - startTime;
    const t = Math.min(elapsed / duration, 1);
    
    // Ease out cubic
    const ease = 1 - Math.pow(1 - t, 3);
    
    panX = startPanX + (finalPanX - startPanX) * ease;
    panY = startPanY + (finalPanY - startPanY) * ease;
    targetPanX = panX;
    targetPanY = panY;
    
    clampPan();
    updateTransform();
    
    if (t < 1) {
      hintAnimation = requestAnimationFrame(animate);
    }
  }
  
  if (hintAnimation) cancelAnimationFrame(hintAnimation);
  hintAnimation = requestAnimationFrame(animate);
}

// ===== INPUT HANDLING =====
function setupInput() {
  // Mouse
  container.addEventListener('mousedown', e => {
    if (!gameActive) return;
    stopMomentum();
    
    dragging = true;
    clickIntent = true;
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    panStartX = panX;
    panStartY = panY;
    lastDragX = e.clientX;
    lastDragY = e.clientY;
    lastDragTime = performance.now();
  });
  
  window.addEventListener('mousemove', e => {
    // Custom cursor
    if (customCursor && gameActive) {
      customCursor.style.left = e.clientX + 'px';
      customCursor.style.top = e.clientY + 'px';
    }
    
    if (!dragging) return;
    
    const dx = e.clientX - dragStartX;
    const dy = e.clientY - dragStartY;
    
    if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
      clickIntent = false;
    }
    
    // Calculate velocity
    const now = performance.now();
    const dt = now - lastDragTime;
    if (dt > 0) {
      velocityX = (e.clientX - lastDragX) / dt * 16;
      velocityY = (e.clientY - lastDragY) / dt * 16;
    }
    lastDragX = e.clientX;
    lastDragY = e.clientY;
    lastDragTime = now;
    
    panX = panStartX + dx;
    panY = panStartY + dy;
    targetPanX = panX;
    targetPanY = panY;
    clampPan();
    updateTransform();
  });
  
  window.addEventListener('mouseup', e => {
    if (dragging) {
      if (clickIntent) {
        handleClick(e.clientX, e.clientY);
      } else {
        // Apply momentum
        applyMomentum();
      }
    }
    dragging = false;
  });
  
  container.addEventListener('mouseenter', () => {
    if (customCursor && gameActive) {
      customCursor.classList.add('visible');
    }
  });
  
  container.addEventListener('mouseleave', () => {
    if (customCursor) {
      customCursor.classList.remove('visible');
    }
  });
  
  container.addEventListener('mousedown', () => {
    if (customCursor) customCursor.classList.add('active');
  });
  
  window.addEventListener('mouseup', () => {
    if (customCursor) customCursor.classList.remove('active');
  });
  
  // Wheel zoom
  container.addEventListener('wheel', e => {
    if (!gameActive || !imgLoaded) return;
    e.preventDefault();
    
    const oldScale = scale;
    const zoomFactor = e.deltaY < 0 ? 1.15 : 0.87;
    targetScale = Math.max(minScale, Math.min(4, scale * zoomFactor));
    
    // Zoom toward cursor
    const rect = container.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    
    const newScale = targetScale;
    targetPanX = mx - (mx - panX) * (newScale / oldScale);
    targetPanY = my - (my - panY) * (newScale / oldScale);
    
    // Shimmer on deep zoom
    if (targetScale > 2 && oldScale <= 2) {
      playZoomShimmer();
    }
  }, { passive: false });
  
  // Touch
  let touches = [];
  
  container.addEventListener('touchstart', e => {
    if (!gameActive) return;
    e.preventDefault();
    stopMomentum();
    
    touches = [...e.touches];
    
    if (touches.length === 1) {
      dragging = true;
      clickIntent = true;
      dragStartX = touches[0].clientX;
      dragStartY = touches[0].clientY;
      panStartX = panX;
      panStartY = panY;
      lastDragX = touches[0].clientX;
      lastDragY = touches[0].clientY;
      lastDragTime = performance.now();
      
      // Double tap detection
      const now = performance.now();
      const dx = Math.abs(touches[0].clientX - lastTapX);
      const dy = Math.abs(touches[0].clientY - lastTapY);
      
      if (now - lastTapTime < 300 && dx < 30 && dy < 30) {
        // Double tap - zoom
        handleDoubleTap(touches[0].clientX, touches[0].clientY);
        clickIntent = false;
      }
      
      lastTapTime = now;
      lastTapX = touches[0].clientX;
      lastTapY = touches[0].clientY;
    }
    
    if (touches.length === 2) {
      lastPinchDist = Math.hypot(
        touches[1].clientX - touches[0].clientX,
        touches[1].clientY - touches[0].clientY
      );
      clickIntent = false;
    }
  }, { passive: false });
  
  container.addEventListener('touchmove', e => {
    if (!gameActive) return;
    e.preventDefault();
    
    const ts = [...e.touches];
    
    if (ts.length === 1 && dragging) {
      const dx = ts[0].clientX - dragStartX;
      const dy = ts[0].clientY - dragStartY;
      
      if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
        clickIntent = false;
      }
      
      // Velocity
      const now = performance.now();
      const dt = now - lastDragTime;
      if (dt > 0) {
        velocityX = (ts[0].clientX - lastDragX) / dt * 16;
        velocityY = (ts[0].clientY - lastDragY) / dt * 16;
      }
      lastDragX = ts[0].clientX;
      lastDragY = ts[0].clientY;
      lastDragTime = now;
      
      panX = panStartX + dx;
      panY = panStartY + dy;
      targetPanX = panX;
      targetPanY = panY;
      clampPan();
      updateTransform();
    }
    
    if (ts.length === 2) {
      const dist = Math.hypot(
        ts[1].clientX - ts[0].clientX,
        ts[1].clientY - ts[0].clientY
      );
      
      const oldScale = scale;
      scale *= dist / lastPinchDist;
      scale = Math.max(minScale, Math.min(4, scale));
      targetScale = scale;
      
      const mx = (ts[0].clientX + ts[1].clientX) / 2;
      const my = (ts[0].clientY + ts[1].clientY) / 2;
      
      panX = mx - (mx - panX) * (scale / oldScale);
      panY = my - (my - panY) * (scale / oldScale);
      targetPanX = panX;
      targetPanY = panY;
      clampPan();
      updateTransform();
      
      lastPinchDist = dist;
      
      // Shimmer
      if (scale > 2 && oldScale <= 2) {
        playZoomShimmer();
      }
    }
  }, { passive: false });
  
  container.addEventListener('touchend', e => {
    if (dragging && clickIntent && e.changedTouches.length === 1) {
      handleClick(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
    } else if (!clickIntent && e.touches.length === 0) {
      applyMomentum();
    }
    dragging = false;
  });
  
  // Hint button
  hintBtn.addEventListener('click', animateHint);
  
  // Mute button
  muteBtn.addEventListener('click', toggleMute);
}

function handleDoubleTap(x, y) {
  if (!imgLoaded) return;
  
  if (scale > minScale * 1.5) {
    // Zoom out
    targetScale = minScale;
    targetPanX = (container.clientWidth - imgWidth * minScale) / 2;
    targetPanY = (container.clientHeight - imgHeight * minScale) / 2;
  } else {
    // Zoom in 2x centered on tap
    const newScale = Math.min(minScale * 2.5, 4);
    const oldScale = scale;
    
    targetScale = newScale;
    targetPanX = x - (x - panX) * (newScale / oldScale);
    targetPanY = y - (y - panY) * (newScale / oldScale);
  }
}

// ===== RESIZE HANDLING =====
function handleResize() {
  if (!imgLoaded || !gameActive) return;
  
  const sx = container.clientWidth / imgWidth;
  const sy = container.clientHeight / imgHeight;
  const newMinScale = Math.max(sx, sy);
  
  // Adjust scale if below new minimum
  if (scale < newMinScale) {
    scale = newMinScale;
    targetScale = scale;
  }
  minScale = newMinScale;
  
  clampPan();
  updateTransform();
}

// ===== TITLE SCREEN =====
function initTitle() {
  container = document.getElementById('game-container');
  imgEl = document.getElementById('scene-img');
  hud = document.getElementById('hud');
  hintBtn = document.getElementById('hint-btn');
  muteBtn = document.getElementById('mute-btn');
  customCursor = document.getElementById('custom-cursor');
  
  // Position yellow circle
  const yc = document.getElementById('title-yellow-circle');
  const margin = 80;
  const W = window.innerWidth;
  const H = window.innerHeight;
  
  // Position in corner/edge, avoiding center
  let x, y;
  const isMobile = W < 768;
  
  if (isMobile) {
    // Fixed position on mobile - bottom right
    x = W - margin - 68;
    y = H - margin - 120;
  } else {
    // Random corner on desktop
    const corners = [
      { x: margin, y: margin }, // top-left
      { x: W - margin - 68, y: margin }, // top-right
      { x: margin, y: H - margin - 68 }, // bottom-left
      { x: W - margin - 68, y: H - margin - 68 } // bottom-right
    ];
    const corner = corners[Math.floor(Math.random() * corners.length)];
    x = corner.x + (Math.random() - 0.5) * 40;
    y = corner.y + (Math.random() - 0.5) * 40;
  }
  
  yc.style.left = Math.max(20, Math.min(W - 88, x)) + 'px';
  yc.style.top = Math.max(20, Math.min(H - 88, y)) + 'px';
  
  // Preload scene 1
  const startBtn = document.getElementById('start-btn');
  
  preloadImage(SCENES[0].img).then(() => {
    startBtn.classList.remove('loading');
    startBtn.classList.add('ready');
    startBtn.textContent = 'START';
  }).catch(() => {
    startBtn.classList.remove('loading');
    startBtn.textContent = 'START';
  });
  
  // Start button handler
  startBtn.addEventListener('click', () => {
    if (startBtn.classList.contains('loading')) return;
    
    // Init audio on user interaction
    initAudio();
    
    // Hide title
    document.getElementById('title-screen').style.display = 'none';
    yc.style.display = 'none';
    
    // Show game UI
    hud.classList.add('visible');
    hintBtn.style.display = 'block';
    muteBtn.style.display = 'block';
    container.classList.add('playing');
    
    // Check for touch device
    if ('ontouchstart' in window) {
      customCursor.style.display = 'none';
    }
    
    // Start
    setupInput();
    startGameLoop();
    startAmbient();
    loadScene(0);
  });
  
  // Share button
  document.getElementById('share-btn').addEventListener('click', shareResults);
  
  // Play again button
  document.getElementById('play-again-btn').addEventListener('click', restartGame);
  
  // Window resize
  window.addEventListener('resize', handleResize);
}

// ===== INIT =====
window.addEventListener('load', initTitle);
</script>
</body>
</html>
